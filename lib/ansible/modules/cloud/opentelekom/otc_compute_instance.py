#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2018 Huawei
# GNU General Public License v3.0+ (see COPYING or
# https://www.gnu.org/licenses/gpl-3.0.txt)
# ----------------------------------------------------------------------------
#
#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
#
# ----------------------------------------------------------------------------
#
#     This file is automatically generated by Magic Modules and manual
#     changes will be clobbered when the file is regenerated.
#
#     Please read more about how to change this file at
#     https://www.github.com/huaweicloud/magic-modules
#
# ----------------------------------------------------------------------------

from __future__ import absolute_import, division, print_function
__metaclass__ = type

###############################################################################
# Documentation
###############################################################################

ANSIBLE_METADATA = {'metadata_version': '1.1',
                    'status': ["preview"],
                    'supported_by': 'community'}

DOCUMENTATION = '''
---
module: otc_compute_instance
description:
    - Represents an Virtual Machine resource.
short_description: Creates a resource of Instance in Opentelekom Cloud
version_added: 2.7
author: Huawei Inc. (@huaweicloud)
requirements:
    - python >= 2.6
    - requests >= 2.18.4
    - keystoneauth1 >= 3.6.0
options:
    state:
        description:
            - Whether the given object should exist in Opentelekom Cloud.
        choices: ['present', 'absent']
        default: 'present'
    ipv4:
        description:
            - IPv4 address that should be used to access this server.
        required: false
    ipv6:
        description:
            - IPv6 address that should be used to access this server.
        required: false
    config_drive:
        description:
            - Indicates whether a configuration drive enables metadata
              injection.
        required: false
        type: bool
    flavor:
        description:
            - the uuid of flavor.
        required: true
    image:
        description:
            - the uuid of image.
        required: true
    key_pair:
        description:
            - the key pair name.
        required: false
    metadata:
        description:
            - the metadata of instance.
        required: false
    name:
        description:
            - the name of instance.
        required: true
    disk_config:
        description:
            - specify how to partition disk.
        required: false
    az:
        description:
            - availability zone.
        required: false
    security_groups:
        description:
            - the groups of security.
        required: false
        suboptions:
            name:
                description:
                    - the name of security group.
                required: false
    desc:
        description:
            - description of server.
        required: false
    admin_pass:
        description:
            - the administrative password of the server.
        required: false
    auto_recovery:
        description:
            - specify whether to set auto recovery for this server.
        required: false
        type: bool
    user_data:
        description:
            - the user data.
        required: false
    networks:
        description:
            - the network to which instance will attach.
        required: true
        suboptions:
            uuid:
                description:
                    - the uuid of network.
                required: false
            port:
                description:
                    - the port to which instance will attach to.
                required: false
            private_ip:
                description:
                    - the private ip of instance.
                required: false
            tag:
                description:
                    - the tag of network.
                required: false
    personality:
        description:
            - the file path and content to inject into server at launch.
        required: false
        suboptions:
            path:
                description:
                    - the path of file.
                required: false
            content:
                description:
                    - the content of file.
                required: false
    scheduler_hints:
        description:
            - the data sent to the scheduler.
        required: false
        suboptions:
            build_near_host_ip:
                description:
                    - schedule the server on a host.
                required: false
            cidr:
                description:
                    - schedule the server on a host.
                required: false
            different_cell:
                description:
                    - a list of cell routes.
                required: false
            different_host:
                description:
                    - a list of server uuids.
                required: false
            group:
                description:
                    - the server group uuid.
                required: false
            query:
                description:
                    - schedule the server by using a custom filter.
                required: false
            same_host:
                description:
                    - a list of server uuids.
                required: false
            target_cell:
                description:
                    - a target cell name.
                required: false
extends_documentation_fragment: hwc
'''

EXAMPLES = '''
- name: create a instance
  otc_compute_instance:
      identity_endpoint: "{{ identity_endpoint }}"
      user_name: "{{ user_name }}"
      password: "{{ password }}"
      domain_name: "{{ domain_name }}"
      project_name: "{{ project_name }}"
      region: "{{ region }}"
      name: "ansible_compute_instance_test"
      image: "{{ image_id }}"
      flavor: "{{ flavor_id }}"
      network:
        - uuid: "{{ network_id }}"
      state: present
'''

RETURN = '''
    ipv4:
        description:
            - IPv4 address that should be used to access this server.
        returned: success
        type: str
    ipv6:
        description:
            - IPv6 address that should be used to access this server.
        returned: success
        type: str
    addresses:
        description:
            - the addresses of the server.
        returned: success
        type: dict
    config_drive:
        description:
            - Indicates whether a configuration drive enables metadata
              injection.
        returned: success
        type: bool
    created_time:
        description:
            - created time.
        returned: success
        type: str
    flavor:
        description:
            - the uuid of flavor.
        returned: success
        type: str
    host_id:
        description:
            - id of host.
        returned: success
        type: str
    id:
        description:
            - the uuid of server.
        returned: success
        type: str
    image:
        description:
            - the uuid of image.
        returned: success
        type: str
    key_pair:
        description:
            - the key pair name.
        returned: success
        type: str
    links:
        description:
            - links to the server.
        returned: success
        type: complex
        contains:
            href:
                description:
                    - the link itself.
                returned: success
                type: str
            rel:
                description:
                    - the type of link.
                returned: success
                type: str
    metadata:
        description:
            - the metadata of instance.
        returned: success
        type: dict
    name:
        description:
            - the name of instance.
        returned: success
        type: str
    disk_config:
        description:
            - specify how to partition disk.
        returned: success
        type: str
    az:
        description:
            - availability zone.
        returned: success
        type: str
    power_state:
        description:
            - the power state of server.
        returned: success
        type: int
    task_state:
        description:
            - the task state of server.
        returned: success
        type: str
    vm_state:
        description:
            - the vm state.
        returned: success
        type: str
    attached_volumes:
        description:
            - the attached volumes.
        returned: success
        type: complex
        contains:
            volume_id:
                description:
                    - the uuid of the attached volume.
                returned: success
                type: str
            delete_on_termination:
                description:
                    - indicate if the attached volume will be deleted when
                      server is deleted.
                returned: success
                type: bool
    launched_at:
        description:
            - the date and time when the server was launched.
        returned: success
        type: str
    terminated_at:
        description:
            - the date and time when the server was terminated.
        returned: success
        type: str
    security_groups:
        description:
            - the groups of security.
        returned: success
        type: complex
        contains:
            name:
                description:
                    - the name of security group.
                returned: success
                type: str
    status:
        description:
            - the server status.
        returned: success
        type: str
    tenant_id:
        description:
            - the tenant id.
        returned: success
        type: str
    updated_time:
        description:
            - updated time.
        returned: success
        type: str
    user_id:
        description:
            - the user id of user who owns the server.
        returned: success
        type: str
    fault:
        description:
            - the details of fault message.
        returned: success
        type: complex
        contains:
            created:
                description:
                    - the date and time when the exception was raised.
                returned: success
                type: str
            message:
                description:
                    - the error message.
                returned: success
                type: str
            details:
                description:
                    - the stack trace.
                returned: success
                type: str
            code:
                description:
                    - the error code.
                returned: success
                type: int
    progress:
        description:
            - the percentage value of the operation progress.
        returned: success
        type: int
    locked:
        description:
            - indicate if the instance is locked.
        returned: success
        type: bool
    host_status:
        description:
            - the host status.
        returned: success
        type: str
    desc:
        description:
            - description of server.
        returned: success
        type: str
    admin_pass:
        description:
            - the administrative password of the server.
        returned: success
        type: str
    auto_recovery:
        description:
            - specify whether to set auto recovery for this server.
        returned: success
        type: bool
    user_data:
        description:
            - the user data.
        returned: success
        type: str
    networks:
        description:
            - the network to which instance will attach.
        returned: success
        type: complex
        contains:
            uuid:
                description:
                    - the uuid of network.
                returned: success
                type: str
            port:
                description:
                    - the port to which instance will attach to.
                returned: success
                type: str
            private_ip:
                description:
                    - the private ip of instance.
                returned: success
                type: str
            tag:
                description:
                    - the tag of network.
                returned: success
                type: str
    personality:
        description:
            - the file path and content to inject into server at launch.
        returned: success
        type: complex
        contains:
            path:
                description:
                    - the path of file.
                returned: success
                type: str
            content:
                description:
                    - the content of file.
                returned: success
                type: str
    scheduler_hints:
        description:
            - the data sent to the scheduler.
        returned: success
        type: complex
        contains:
            build_near_host_ip:
                description:
                    - schedule the server on a host.
                returned: success
                type: str
            cidr:
                description:
                    - schedule the server on a host.
                returned: success
                type: str
            different_cell:
                description:
                    - a list of cell routes.
                returned: success
                type: list
            different_host:
                description:
                    - a list of server uuids.
                returned: success
                type: list
            group:
                description:
                    - the server group uuid.
                returned: success
                type: str
            query:
                description:
                    - schedule the server by using a custom filter.
                returned: success
                type: str
            same_host:
                description:
                    - a list of server uuids.
                returned: success
                type: list
            target_cell:
                description:
                    - a target cell name.
                returned: success
                type: str
'''

###############################################################################
# Imports
###############################################################################

from ansible.module_utils.hwc_utils import (HwcSession, HwcModule,
                                            DictComparison, navigate_hash,
                                            remove_nones_from_dict,
                                            remove_empty_from_dict)
import json
import re
import time

###############################################################################
# Main
###############################################################################


def main():
    """Main function"""

    module = HwcModule(
        argument_spec=dict(
            state=dict(default='present', choices=['present', 'absent'], type='str'),
            ipv4=dict(type='str'),
            ipv6=dict(type='str'),
            config_drive=dict(type='bool'),
            flavor=dict(required=True, type='str'),
            image=dict(required=True, type='str'),
            key_pair=dict(type='str'),
            metadata=dict(type='dict'),
            name=dict(required=True, type='str'),
            disk_config=dict(type='str'),
            az=dict(type='str'),
            security_groups=dict(type='list', elements='dict', options=dict(
                name=dict(type='str')
            )),
            desc=dict(type='str'),
            admin_pass=dict(type='str'),
            auto_recovery=dict(type='bool'),
            user_data=dict(type='str'),
            networks=dict(required=True, type='list', elements='dict', options=dict(
                uuid=dict(type='str'),
                port=dict(type='str'),
                private_ip=dict(type='str'),
                tag=dict(type='str')
            )),
            personality=dict(type='list', elements='dict', options=dict(
                path=dict(type='str'),
                content=dict(type='str')
            )),
            scheduler_hints=dict(type='dict', options=dict(
                build_near_host_ip=dict(type='str'),
                cidr=dict(type='str'),
                different_cell=dict(type='list', elements='str'),
                different_host=dict(type='list', elements='str'),
                group=dict(type='str'),
                query=dict(type='str'),
                same_host=dict(type='list', elements='str'),
                target_cell=dict(type='str')
            ))
        )
    )
    session = HwcSession(module, 'compute')

    state = module.params['state']

    if not module.params.get("id"):
        module.params['id'] = get_resource_id(session)

    fetch = get_resource(session)
    changed = False

    if fetch:
        if state == 'present':
            expect = _get_editable_properties(module)
            current_state = response_to_hash(module, fetch)
            if is_different(expect, current_state):
                fetch = update_resource(session, current_state, fetch)
                fetch = response_to_hash(module, fetch)
                changed = True
            else:
                fetch = current_state
        else:
            delete(session, self_link(session))
            fetch = {}
            changed = True
    else:
        if state == 'present':
            fetch = create_resource(session)
            fetch = response_to_hash(module, fetch)
            changed = True
        else:
            fetch = {}

    fetch.update({'changed': changed})

    module.exit_json(**fetch)


def create(session, link, success_codes=None):
    if not success_codes:
        success_codes = [201, 202]
    module = session.module
    r = return_if_object(module, session.post(link, resource_to_create(module)), success_codes)

    complete_states = ['ACTIVE']
    allowed_states = ['BUILD', 'ACTIVE']
    timeout = 60 * int(module.params['timeouts']['create'].rstrip('m'))
    r = wait_for_operation(session, r, timeout, complete_states, allowed_states)
    return r.get('server')


def update(session, link, success_codes=None):
    if not success_codes:
        success_codes = [201, 202]
    module = session.module
    r = return_if_object(module, session.put(link, resource_to_update(module)), success_codes)

    complete_states = ['ACTIVE']
    allowed_states = ['BUILD', 'ACTIVE']
    timeout = 60 * int(module.params['timeouts']['update'].rstrip('m'))
    r = wait_for_operation(session, r, timeout, complete_states, allowed_states)
    return r.get('server')


def delete(session, link, success_codes=None):
    if not success_codes:
        success_codes = [202, 204]
    return_if_object(session.module, session.delete(link), success_codes, False)

    timeout = 60 * int(session.module.params['timeouts']['delete'].rstrip('m'))
    wait_for_delete(session, link, timeout)


def fetch_resource(session, link, success_codes=None):
    if not success_codes:
        success_codes = [200]
    return return_if_object(session.module, session.get(link), success_codes)


def get_resource(session):
    link = self_link(session)
    # the link will include Nones if required format parameters are missed
    if re.search('/None/|/None$', link):
        return None

    fetch = fetch_resource(session, link, [200, 203])
    if not fetch:
        return fetch
    fetch = fetch.get('server')

    r = InstancAutoRecoverExProperty(session).fetch()
    if isinstance(r, dict):
        fetch.update(r)

    return fetch


def update_resource(session, current_state, resource):
    params = session.module.params
    obj = resource
    expect = _get_resource_editable_properties(session.module)
    if is_different(expect, current_state):
        obj = update(session, self_link(session), [200])

    result = {}
    expect = {"auto_recovery": params.get("auto_recovery"),}
    actual = {"auto_recovery": current_state.get("auto_recovery"),}
    if DictComparison(expect) != DictComparison(actual):
        r = InstancAutoRecoverExProperty(session).update()
        if r:
            result.update(r)

    if result:
        obj.update(result)
    return obj


def create_resource(session):
    obj = create(session, collection(session))
    session.module.params['id'] = obj.get('id', None)

    params = session.module.params
    result = {}
    if params.get('auto_recovery') is not None:
        r = InstancAutoRecoverExProperty(session).update()
        if r:
            result.update(r)

    if result:
        obj.update(result)
    return obj


def link_wrapper(f):
    def _wrapper(session, *args, **kwargs):
        try:
            return f(session, *args, **kwargs)
        except KeyError as ex:
            session.module.fail_json(
                msg="Mapping keys(%s) are not found in generating link" % ex)

    return _wrapper


def get_resource_id(session):
    module = session.module
    link = list_link(session)
    r = fetch_resource(session, link)
    if r is None:
        return None
    r = r.get('servers', [])
    ids = set()
    for i in r:
        ids.add(i.get('id'))
    if not ids:
        return None
    elif len(ids) == 1:
        return ids.pop()
    else:
        module.fail_json(msg="Multiple resources are found")


@link_wrapper
def list_link(session):
    url = "{endpoint}servers?limit=10&name={name}"

    combined = session.module.params.copy()
    combined['endpoint'] = session.get_service_endpoint('compute')

    return url.format(**combined)


@link_wrapper
def self_link(session):
    url = "{endpoint}servers/{id}"

    combined = session.module.params.copy()
    combined['endpoint'] = session.get_service_endpoint('compute')

    return url.format(**combined)


@link_wrapper
def collection(session):
    url = "{endpoint}servers"

    combined = session.module.params.copy()
    combined['endpoint'] = session.get_service_endpoint('compute')

    return url.format(**combined)


def return_if_object(module, response, success_codes, has_content=True):
    code = response.status_code

    # If not found, return nothing.
    if code == 404:
        return None

    success_codes = [200, 201, 202, 203, 204, 205, 206, 207, 208, 226]
    # If no content, return nothing.
    if code in success_codes and not has_content:
        return None

    result = None
    try:
        result = response.json()
    except getattr(json.decoder, 'JSONDecodeError', ValueError) as inst:
        module.fail_json(msg="Invalid JSON response with error: %s" % inst)

    if code not in success_codes:
        for i in [['message'], ['error', 'message']]:
            msg = navigate_hash(result, i)
            if msg:
                module.fail_json(msg="request failed, %s" % msg)
                break
        else:
            module.fail_json(msg="request failed, return code=%d" % code)

    return result


def is_different(expect, actual):
    # Remove all output-only from actual.
    actual_vals = {}
    for k, v in actual.items():
        if k in expect:
            actual_vals[k] = v

    expect_vals = {}
    for k, v in expect.items():
        if k in actual:
            expect_vals[k] = v

    return DictComparison(expect_vals) != DictComparison(actual_vals)


def resource_to_create(module):
    request = remove_empty_from_dict({
        u'user_data': module.params.get('user_data'),
        u'networks': InstanceNetworksArray(module.params.get('networks', []), module).to_request(),
        u'personality': InstancePersonalitArray(module.params.get('personality', []), module).to_request(),
        u'accessIPv4': module.params.get('ipv4'),
        u'accessIPv6': module.params.get('ipv6'),
        u'config_drive': module.params.get('config_drive'),
        u'flavorRef': module.params.get('flavor'),
        u'imageRef': module.params.get('image'),
        u'key_name': module.params.get('key_pair'),
        u'metadata': module.params.get('metadata'),
        u'name': module.params.get('name'),
        u'OS-DCF:diskConfig': module.params.get('disk_config'),
        u'availability_zone': module.params.get('az'),
        u'security_groups': InstancSecuritGroupsArray(module.params.get('security_groups', []), module).to_request(),
        u'description': module.params.get('desc'),
        u'adminPass': module.params.get('admin_pass')
    })
    alone_param = remove_empty_from_dict({
         u'OS-SCH-HNT:scheduler_hints': InstancSchedulHints(module.params.get('scheduler_hints', {}), module).to_request()
    })
    v = {'server': request}
    v.update(alone_param)
    return v


def resource_to_update(module):
    request = remove_nones_from_dict({
        u'accessIPv4': module.params.get('ipv4'),
        u'accessIPv6': module.params.get('ipv6'),
        u'name': module.params.get('name'),
        u'OS-DCF:diskConfig': module.params.get('disk_config'),
        u'description': module.params.get('desc')
    })
    return {'server': request}


def _get_resource_editable_properties(module):
    return remove_nones_from_dict({
        "ipv4": module.params.get("ipv4"),
        "ipv6": module.params.get("ipv6"),
        "name": module.params.get("name"),
        "disk_config": module.params.get("disk_config"),
        "desc": module.params.get("desc"),
    })


def _get_editable_properties(module):
    return remove_nones_from_dict({
        "ipv4": module.params.get("ipv4"),
        "ipv6": module.params.get("ipv6"),
        "name": module.params.get("name"),
        "disk_config": module.params.get("disk_config"),
        "desc": module.params.get("desc"),
        "auto_recovery": module.params.get("auto_recovery"),
    })


# Remove unnecessary properties from the response.
# This is for doing comparisons with Ansible's current parameters.
def response_to_hash(module, response):
    return {
        u'ipv4': response.get(u'accessIPv4'),
        u'ipv6': response.get(u'accessIPv6'),
        u'addresses': response.get(u'addresses'),
        u'config_drive': _config_drive_convert_from_response(response.get('config_drive')),
        u'created_time': response.get(u'created'),
        u'flavor': _flavor_convert_from_response(response.get('flavor')),
        u'host_id': response.get(u'hostId'),
        u'id': response.get(u'id'),
        u'image': _image_convert_from_response(response.get('image')),
        u'key_pair': response.get(u'key_name'),
        u'links': InstanceLinksArray(response.get(u'links', []), module).from_response(),
        u'metadata': response.get(u'metadata'),
        u'name': response.get(u'name'),
        u'disk_config': response.get(u'OS-DCF:diskConfig'),
        u'az': response.get(u'OS-EXT-AZ:availability_zone'),
        u'power_state': _power_state_convert_from_response(response.get('OS-EXT-STS:power_state')),
        u'task_state': response.get(u'OS-EXT-STS:task_state'),
        u'vm_state': response.get(u'OS-EXT-STS:vm_state'),
        u'attached_volumes': InstancAttacheVolumesArray(response.get(u'os-extended-volumes:volumes_attached', []), module).from_response(),
        u'launched_at': response.get(u'OS-SRV-USG:launched_at'),
        u'terminated_at': response.get(u'OS-SRV-USG:terminated_at'),
        u'security_groups': InstancSecuritGroupsArray(response.get(u'security_groups', []), module).from_response(),
        u'status': response.get(u'status'),
        u'tenant_id': response.get(u'tenant_id'),
        u'updated_time': response.get(u'updated'),
        u'user_id': response.get(u'user_id'),
        u'fault': InstanceFaultArray(response.get(u'fault', []), module).from_response(),
        u'progress': response.get(u'progress'),
        u'locked': response.get(u'locked'),
        u'host_status': response.get(u'host_status'),
        u'desc': response.get(u'description'),
        u'admin_pass': response.get(u'adminPass'),
        u'auto_recovery': _auto_recovery_convert_from_response(response.get('support_auto_recovery'))
    }


@link_wrapper
def async_op_url(session, extra_data=None):
    url = "{endpoint}servers/{op_id}"

    combined = session.module.params.copy()
    if extra_data:
        combined.update(extra_data)

    combined['endpoint'] = session.get_service_endpoint('compute')

    return url.format(**combined)


def wait_for_operation(session, op_result, timeout, complete_states, allowed_states):
    op_id = navigate_hash(op_result, ['server', 'id'])
    url = async_op_url(session, {'op_id': op_id})
    return wait_for_completion(session, url, timeout, complete_states, allowed_states)


def wait_for_completion(session, op_uri, timeout, complete_states, allowed_states):
    module = session.module
    end = time.time() + timeout
    while time.time() <= end:
        try:
            op_result = fetch_resource(session, op_uri)
        except Exception:
            time.sleep(1.0)
            continue

        raise_if_errors(op_result, module)

        status = navigate_hash(op_result, ['server', 'status'])
        if status not in allowed_states:
            module.fail_json(msg="Invalid async operation status %s" % status)
        if status in complete_states:
            return op_result
        time.sleep(1.0)

    module.fail_json(msg="Timeout to wait completion")


def wait_for_delete(session, link, timeout):
    end = time.time() + timeout
    while time.time() <= end:
        try:
            resp = session.get(link)
            if resp.status_code == 404:
                return
        except Exception:
            pass

        time.sleep(1.0)

    session.module.fail_json(msg="Timeout to wait for deletion to be completed")


def raise_if_errors(response, module):
    failed = navigate_hash(response, ['server', 'fault'])
    if failed:
        module.fail_json(msg=navigate_hash(response, ['server', 'fault', 'message']))


class InstanceLinksArray(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = []

    def to_request(self):
        items = []
        for item in self.request:
            items.append(self._request_for_item(item))
        return items

    def from_response(self):
        items = []
        for item in self.request:
            items.append(self._response_from_item(item))
        return items

    def _request_for_item(self, item):
        return {
            u'href': item.get('href'),
            u'rel': item.get('rel')
        }

    def _response_from_item(self, item):
        return {
            u'href': item.get(u'href'),
            u'rel': item.get(u'rel')
        }


class InstancAttacheVolumesArray(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = []

    def to_request(self):
        items = []
        for item in self.request:
            items.append(self._request_for_item(item))
        return items

    def from_response(self):
        items = []
        for item in self.request:
            items.append(self._response_from_item(item))
        return items

    def _request_for_item(self, item):
        return {
            u'id': item.get('volume_id'),
            u'delete_on_termination': item.get('delete_on_termination')
        }

    def _response_from_item(self, item):
        return {
            u'volume_id': item.get(u'id'),
            u'delete_on_termination': item.get(u'delete_on_termination')
        }


class InstancSecuritGroupsArray(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = []

    def to_request(self):
        items = []
        for item in self.request:
            items.append(self._request_for_item(item))
        return items

    def from_response(self):
        items = []
        for item in self.request:
            items.append(self._response_from_item(item))
        return items

    def _request_for_item(self, item):
        return {
            u'name': item.get('name')
        }

    def _response_from_item(self, item):
        return {
            u'name': item.get(u'name')
        }


class InstanceFaultArray(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = []

    def to_request(self):
        items = []
        for item in self.request:
            items.append(self._request_for_item(item))
        return items

    def from_response(self):
        items = []
        for item in self.request:
            items.append(self._response_from_item(item))
        return items

    def _request_for_item(self, item):
        return {
            u'created': item.get('created'),
            u'message': item.get('message'),
            u'details': item.get('details'),
            u'code': item.get('code')
        }

    def _response_from_item(self, item):
        return {
            u'created': item.get(u'created'),
            u'message': item.get(u'message'),
            u'details': item.get(u'details'),
            u'code': item.get(u'code')
        }


class InstanceNetworksArray(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = []

    def to_request(self):
        items = []
        for item in self.request:
            items.append(self._request_for_item(item))
        return items

    def from_response(self):
        items = []
        for item in self.request:
            items.append(self._response_from_item(item))
        return items

    def _request_for_item(self, item):
        return {
            u'uuid': item.get('uuid'),
            u'port': item.get('port'),
            u'fixed_ip': item.get('private_ip'),
            u'tag': item.get('tag')
        }

    def _response_from_item(self, item):
        return {
            u'uuid': item.get(u'uuid'),
            u'port': item.get(u'port'),
            u'private_ip': item.get(u'fixed_ip'),
            u'tag': item.get(u'tag')
        }


class InstancePersonalitArray(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = []

    def to_request(self):
        items = []
        for item in self.request:
            items.append(self._request_for_item(item))
        return items

    def from_response(self):
        items = []
        for item in self.request:
            items.append(self._response_from_item(item))
        return items

    def _request_for_item(self, item):
        return {
            u'path': item.get('path'),
            u'content': item.get('content')
        }

    def _response_from_item(self, item):
        return {
            u'path': item.get(u'path'),
            u'content': item.get(u'content')
        }


class InstancSchedulHints(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return {
            u'build_near_host_ip': self.request.get('build_near_host_ip'),
            u'cidr': self.request.get('cidr'),
            u'different_cell': self.request.get('different_cell'),
            u'different_host': self.request.get('different_host'),
            u'group': self.request.get('group'),
            u'query': self.request.get('query'),
            u'same_host': self.request.get('same_host'),
            u'target_cell': self.request.get('target_cell')
        }

    def from_response(self):
        return {
            u'build_near_host_ip': self.request.get(u'build_near_host_ip'),
            u'cidr': self.request.get(u'cidr'),
            u'different_cell': self.request.get(u'different_cell'),
            u'different_host': self.request.get(u'different_host'),
            u'group': self.request.get(u'group'),
            u'query': self.request.get(u'query'),
            u'same_host': self.request.get(u'same_host'),
            u'target_cell': self.request.get(u'target_cell')
        }


def _config_drive_convert_from_response(value):
    return value in ['True', 'true']


def _flavor_convert_from_response(value):
    return value.get('id', None)


def _image_convert_from_response(value):
    return value.get('id', None)


def _power_state_convert_from_response(value):
    return {
        0: 'nostate',
        1: 'running',
        3: 'paused',
        4: 'shutdown',
        6: 'crashed',
        7: 'suspended',
    }.get(value, '')


def _auto_recovery_convert_to_request(value):
    return 'true' if value else 'false'


def _auto_recovery_convert_from_response(value):
    return value in ['True', 'true']


class InstancAutoRecoverExProperty(object):
    def __init__(self, session):
        self.module = session.module
        self.session = session

    @link_wrapper
    def _link(self):
        url = "{endpoint}cloudservers/{parent_id}/autorecovery"

        combined = self.module.params.copy()
        combined['parent_id'] = self.module.params['id']
        e = self.session.get_service_endpoint('compute')
        combined['endpoint'] = e.replace("v2", "v1")

        return url.format(**combined)

    def fetch(self):
        return fetch_resource(self.session, self._link())

    def update(self):
        request = remove_nones_from_dict({
            u'support_auto_recovery': _auto_recovery_convert_to_request(self.module.params.get('auto_recovery'))
        })
        result = self.session.put(self._link(), request)
        return_if_object(self.module, result, [204], False)
        return self.fetch()


if __name__ == '__main__':
    main()
