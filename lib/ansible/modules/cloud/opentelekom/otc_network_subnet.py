#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2018 Huawei
# GNU General Public License v3.0+ (see COPYING or
# https://www.gnu.org/licenses/gpl-3.0.txt)
# ----------------------------------------------------------------------------
#
#     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
#
# ----------------------------------------------------------------------------
#
#     This file is automatically generated by Magic Modules and manual
#     changes will be clobbered when the file is regenerated.
#
#     Please read more about how to change this file at
#     https://www.github.com/huaweicloud/magic-modules
#
# ----------------------------------------------------------------------------

from __future__ import absolute_import, division, print_function
__metaclass__ = type

###############################################################################
# Documentation
###############################################################################

ANSIBLE_METADATA = {'metadata_version': '1.1',
                    'status': ["preview"],
                    'supported_by': 'community'}

DOCUMENTATION = '''
---
module: otc_network_subnet
description:
    - Represents an subnet resource.
short_description: Creates a resource of Subnet in Opentelekom Cloud
version_added: 2.7
author: Huawei Inc. (@huaweicloud)
requirements:
    - python >= 2.6
    - requests >= 2.18.4
    - keystoneauth1 >= 3.6.0
options:
    state:
        description:
            - Whether the given object should exist in Opentelekom Cloud.
        choices: ['present', 'absent']
        default: 'present'
    name:
        description:
            - the name of subnet.
        required: true
    cidr:
        description:
            - the network segment on which the subnet resides.
        required: true
    gateway_ip:
        description:
            - the gateway of subnet.
        required: true
    vpc_id:
        description:
            - the id of vpc.
        required: true
    dhcp_enable:
        description:
            - specify whether the DHCP function is enabled for the subnet.
        required: false
        type: bool
    primary_dns:
        description:
            - specify the ip of DNS server 1 on the subnet.
        required: false
    secondary_dns:
        description:
            - specify the ip of DNS server 2 on the subnet.
        required: false
    dns_list:
        description:
            - specify the DNS server address list of a subnet.
        required: false
    availability_zone:
        description:
            - the availability zone to which the subnet belongs.
        required: false
extends_documentation_fragment: hwc
'''

EXAMPLES = '''
- name: create a vpc
  otc_network_vpc:
      identity_endpoint: "{{ identity_endpoint }}"
      user_name: "{{ user_name }}"
      password: "{{ password }}"
      domain_name: "{{ domain_name }}"
      project_name: "{{ project_name }}"
      region: "{{ region }}"
      name: "ansible_network_vpc_test"
      cidr: "192.168.100.0/24"
      state: present
  register: vpc
- name: create a subnet
  otc_network_subnet:
      identity_endpoint: "{{ identity_endpoint }}"
      user_name: "{{ user_name }}"
      password: "{{ password }}"
      domain_name: "{{ domain_name }}"
      project_name: "{{ project_name }}"
      region: "{{ region }}"
      name: "ansible_network_subnet_test"
      cidr: "192.168.100.0/26"
      gateway_ip: "192.168.100.32"
      vpc_id: "{{ vpc.id }}"
      state: present
'''

RETURN = '''
    id:
        description:
            - the id of subnet.
        returned: success
        type: str
    name:
        description:
            - the name of subnet.
        returned: success
        type: str
    cidr:
        description:
            - the network segment on which the subnet resides.
        returned: success
        type: str
    gateway_ip:
        description:
            - the gateway of subnet.
        returned: success
        type: str
    vpc_id:
        description:
            - the id of vpc.
        returned: success
        type: str
    dhcp_enable:
        description:
            - specify whether the DHCP function is enabled for the subnet.
        returned: success
        type: bool
    primary_dns:
        description:
            - specify the ip of DNS server 1 on the subnet.
        returned: success
        type: str
    secondary_dns:
        description:
            - specify the ip of DNS server 2 on the subnet.
        returned: success
        type: str
    dns_list:
        description:
            - specify the DNS server address list of a subnet.
        returned: success
        type: list
    availability_zone:
        description:
            - the availability zone to which the subnet belongs.
        returned: success
        type: str
    status:
        description:
            - the status of subnet.
        returned: success
        type: str
'''

###############################################################################
# Imports
###############################################################################

from ansible.module_utils.hwc_utils import (HwcSession, HwcModule,
                                            DictComparison, navigate_hash,
                                            remove_nones_from_dict,
                                            remove_empty_from_dict)
import json
import re
import time

###############################################################################
# Main
###############################################################################


def main():
    """Main function"""

    module = HwcModule(
        argument_spec=dict(
            state=dict(default='present', choices=['present', 'absent'], type='str'),
            name=dict(required=True, type='str'),
            cidr=dict(required=True, type='str'),
            gateway_ip=dict(required=True, type='str'),
            vpc_id=dict(required=True, type='str'),
            dhcp_enable=dict(type='bool'),
            primary_dns=dict(type='str'),
            secondary_dns=dict(type='str'),
            dns_list=dict(type='list', elements='str'),
            availability_zone=dict(type='str')
        )
    )
    session = HwcSession(module, 'network')

    state = module.params['state']

    if not module.params.get("id"):
        module.params['id'] = get_resource_id(session)

    fetch = get_resource(session)
    changed = False

    if fetch:
        if state == 'present':
            expect = _get_resource_editable_properties(module)
            current_state = response_to_hash(module, fetch)
            if is_different(expect, current_state):
                fetch = update(session, update_delete_url(session), [200])
                fetch = response_to_hash(module, fetch)
                changed = True
            else:
                fetch = current_state
        else:
            delete(session, update_delete_url(session))
            fetch = {}
            changed = True
    else:
        if state == 'present':
            fetch = create(session, collection(session), [200])
            fetch = response_to_hash(module, fetch)
            changed = True
        else:
            fetch = {}

    fetch.update({'changed': changed})

    module.exit_json(**fetch)


def create(session, link, success_codes=None):
    if not success_codes:
        success_codes = [201, 202]
    module = session.module
    r = return_if_object(module, session.post(link, resource_to_create(module)), success_codes)

    complete_states = ['ACTIVE']
    allowed_states = ['UNKNOWN', 'DONW', 'ACTIVE']
    timeout = 60 * int(module.params['timeouts']['create'].rstrip('m'))
    r = wait_for_operation(session, r, timeout, complete_states, allowed_states)
    return r.get('subnet')


def update(session, link, success_codes=None):
    if not success_codes:
        success_codes = [201, 202]
    module = session.module
    r = return_if_object(module, session.put(link, resource_to_update(module)), success_codes)

    complete_states = ['ACTIVE']
    allowed_states = ['UNKNOWN', 'DONW', 'ACTIVE']
    timeout = 60 * int(module.params['timeouts']['update'].rstrip('m'))
    r = wait_for_operation(session, r, timeout, complete_states, allowed_states)
    return r.get('subnet')


def delete(session, link, success_codes=None):
    if not success_codes:
        success_codes = [202, 204]
    return_if_object(session.module, session.delete(link), success_codes, False)

    timeout = 60 * int(session.module.params['timeouts']['delete'].rstrip('m'))
    wait_for_delete(session, link, timeout)


def fetch_resource(session, link, success_codes=None):
    if not success_codes:
        success_codes = [200]
    return return_if_object(session.module, session.get(link), success_codes)


def get_resource(session):
    link = self_link(session)
    # the link will include Nones if required format parameters are missed
    if re.search('/None/|/None$', link):
        return None

    fetch = fetch_resource(session, link)
    if not fetch:
        return fetch
    return fetch.get('subnet')


def link_wrapper(f):
    def _wrapper(session, *args, **kwargs):
        try:
            return f(session, *args, **kwargs)
        except KeyError as ex:
            session.module.fail_json(
                msg="Mapping keys(%s) are not found in generating link" % ex)

    return _wrapper


def get_resource_id(session):
    module = session.module
    link = list_link(session, {'limit': 10, 'marker': '{marker}'})
    p = {'marker': ''}
    v = module.params.get('name')
    ids = set()
    while True:
        r = fetch_resource(session, link.format(**p))
        if r is None:
            break
        r = r.get('subnets', [])
        if r == []:
            break
        for i in r:
            if i.get('name') == v:
                ids.add(i.get('id'))
        if len(ids) >= 2:
            module.fail_json(msg="Multiple resources are found")

        p['marker'] = r[-1].get('id')

    return ids.pop() if ids else None


@link_wrapper
def list_link(session, extra_data=None):
    url = "{endpoint}subnets?limit={limit}&marker={marker}&vpc_id={vpc_id}"

    combined = session.module.params.copy()
    if extra_data:
        combined.update(extra_data)

    combined['endpoint'] = session.get_service_endpoint('vpc')

    return url.format(**combined)


@link_wrapper
def self_link(session):
    url = "{endpoint}subnets/{id}"

    combined = session.module.params.copy()
    combined['endpoint'] = session.get_service_endpoint('vpc')

    return url.format(**combined)


@link_wrapper
def collection(session):
    url = "{endpoint}subnets"

    combined = session.module.params.copy()
    combined['endpoint'] = session.get_service_endpoint('vpc')

    return url.format(**combined)


@link_wrapper
def update_delete_url(session):
    url = "{endpoint}vpcs/{vpc_id}/subnets/{id}"

    combined = session.module.params.copy()
    combined['endpoint'] = session.get_service_endpoint('vpc')

    return url.format(**combined)


def return_if_object(module, response, success_codes, has_content=True):
    code = response.status_code

    # If not found, return nothing.
    if code == 404:
        return None

    success_codes = [200, 201, 202, 203, 204, 205, 206, 207, 208, 226]
    # If no content, return nothing.
    if code in success_codes and not has_content:
        return None

    result = None
    try:
        result = response.json()
    except getattr(json.decoder, 'JSONDecodeError', ValueError) as inst:
        module.fail_json(msg="Invalid JSON response with error: %s" % inst)

    if code not in success_codes:
        for i in [['message'], ['error', 'message']]:
            msg = navigate_hash(result, i)
            if msg:
                module.fail_json(msg="request failed, %s" % msg)
                break
        else:
            module.fail_json(msg="request failed, return code=%d" % code)

    return result


def is_different(expect, actual):
    # Remove all output-only from actual.
    actual_vals = {}
    for k, v in actual.items():
        if k in expect:
            actual_vals[k] = v

    expect_vals = {}
    for k, v in expect.items():
        if k in actual:
            expect_vals[k] = v

    return DictComparison(expect_vals) != DictComparison(actual_vals)


def resource_to_create(module):
    request = remove_empty_from_dict({
        u'name': module.params.get('name'),
        u'cidr': module.params.get('cidr'),
        u'gateway_ip': module.params.get('gateway_ip'),
        u'vpc_id': module.params.get('vpc_id'),
        u'dhcp_enable': module.params.get('dhcp_enable'),
        u'primary_dns': module.params.get('primary_dns'),
        u'secondary_dns': module.params.get('secondary_dns'),
        u'dnsList': module.params.get('dns_list'),
        u'availability_zone': module.params.get('availability_zone')
    })
    return {'subnet': request}


def resource_to_update(module):
    request = remove_nones_from_dict({
        u'name': module.params.get('name'),
        u'dhcp_enable': module.params.get('dhcp_enable'),
        u'primary_dns': module.params.get('primary_dns'),
        u'secondary_dns': module.params.get('secondary_dns'),
        u'dnsList': module.params.get('dns_list')
    })
    return {'subnet': request}


def _get_resource_editable_properties(module):
    return remove_nones_from_dict({
        "name": module.params.get("name"),
        "dhcp_enable": module.params.get("dhcp_enable"),
        "primary_dns": module.params.get("primary_dns"),
        "secondary_dns": module.params.get("secondary_dns"),
        "dns_list": module.params.get("dns_list"),
    })


# Remove unnecessary properties from the response.
# This is for doing comparisons with Ansible's current parameters.
def response_to_hash(module, response):
    return {
        u'id': response.get(u'id'),
        u'name': response.get(u'name'),
        u'cidr': response.get(u'cidr'),
        u'gateway_ip': response.get(u'gateway_ip'),
        u'vpc_id': response.get(u'vpc_id'),
        u'dhcp_enable': response.get(u'dhcp_enable'),
        u'primary_dns': response.get(u'primary_dns'),
        u'secondary_dns': response.get(u'secondary_dns'),
        u'dns_list': response.get(u'dnsList'),
        u'availability_zone': response.get(u'availability_zone'),
        u'status': response.get(u'status')
    }


@link_wrapper
def async_op_url(session, extra_data=None):
    url = "{endpoint}subnets/{op_id}"

    combined = session.module.params.copy()
    if extra_data:
        combined.update(extra_data)

    combined['endpoint'] = session.get_service_endpoint('vpc')

    return url.format(**combined)


def wait_for_operation(session, op_result, timeout, complete_states, allowed_states):
    op_id = navigate_hash(op_result, ['subnet', 'id'])
    url = async_op_url(session, {'op_id': op_id})
    return wait_for_completion(session, url, timeout, complete_states, allowed_states)


def wait_for_completion(session, op_uri, timeout, complete_states, allowed_states):
    module = session.module
    end = time.time() + timeout
    while time.time() <= end:
        try:
            op_result = fetch_resource(session, op_uri)
        except Exception:
            time.sleep(1.0)
            continue

        status = navigate_hash(op_result, ['subnet', 'status'])
        if status not in allowed_states:
            module.fail_json(msg="Invalid async operation status %s" % status)
        if status in complete_states:
            return op_result
        time.sleep(1.0)

    module.fail_json(msg="Timeout to wait completion")


def wait_for_delete(session, link, timeout):
    end = time.time() + timeout
    while time.time() <= end:
        try:
            resp = session.get(link)
            if resp.status_code == 404:
                return
        except Exception:
            pass

        time.sleep(1.0)

    session.module.fail_json(msg="Timeout to wait for deletion to be completed")


if __name__ == '__main__':
    main()
